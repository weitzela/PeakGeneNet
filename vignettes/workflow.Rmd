---
title: "workflow"
output: 
  rmarkdown::html_vignette:
    df_print: kable
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(knitr.table.format = "html")
```

```{r setup, message=FALSE}
# install.packages("pak")
# pak::pak("weitzela/PeakGeneNet")

library(tidyverse)
library(PeakGeneNet)
```

# 1. Peak-Gene Link Preparation  
```{r, echo=FALSE}
# Required objects:
#   * Gene counts: this is a matrix where the row names should be ensembl IDs  
#   * Peak counts: a list object with one or more matrices. Matrices should be in same format as gene counts, with row names as genomic region where the chromosome names, start, and end locations are separated by a punctuation mark (e.g., chr1:123:456 or chr1:123-456). 
# gene_counts[1:3,1:3] |> kableExtra::kable()
# 
# peak_counts$ATACSeq[c(200:202, 1:3),1:3] |> kableExtra::kable()
```

Use these objects to create peak-gene pairs for inclusion in the correlation analysis. The `p2g_info` provides information for individual peaks per gene they will be correlated with. The `correlation_pairs` object is used for reference for all of the correlations that will be run.
```{r}
p2g_ls = createPeak2GeneObjects(
  rownames(gene_counts), peak_counts |> map(rownames), 
  biomaRt::useEnsembl(biomart = "genes", 
                      dataset = "rnorvegicus_gene_ensembl", version = 109), 
  "rn7"
)
p2g_ls$p2g_info[1:5,] |> kableExtra::kable()
p2g_ls$correlation_pairs[1:5,] |> kableExtra::kable()
```

See how many relationships will be tested within each category.  
```{r}
p2g_ls$correlation_pairs |> 
  select(-ensembl_gene_id) |> 
  distinct() |> 
  group_by(link_label, modality_pair) |> 
  tally(name = "No. of Correlations") |> 
  janitor::adorn_totals(where = c("row")) |> 
  mutate(across(where(is.numeric), scales::comma)) |> 
  kableExtra::kable()
```

# 2. Data Adjustment  
If your experimental design is simple, you have a lot of samples, and your data does not show signs of variation, then you can skip this step and move onto the correlation analysis.  

Correlation-based analyses are sensitive to unwanted variation. In multi-factor experimental designs, failing to account for technical effects or biological variables can reduce power, inflate variance, or introduce type I errors. To prepare the data for use in the PeakGeneNet pipeline, we recommend an adjustment strategy targeting both technical and experimental correction while preserving the design and contrast of interest. This approach allows users to ask multiple questions from the same dataset while ensuring that the signal relevant to a contrast of interest is preserved. Different contrasts can be explored by re-running this adjustment step with different protected variables. 

Data provided at this stage should **NOT** be raw counts. Rather, vst, log, or inverse-rank normalized counts. Adjustment is performed in two steps, reflecting standard best practices used in RNA-Seq and epigenomic analyses, where known biology is retained and unwanted variation is removed:  

1.	Removal of technical and latent sources of variation, while explicitly preserving the experimental design.  
    * Latent sources of variation in this example are variables prefixed by "W_" and included because they capture technical effects.  
2.	Regression of additional experimental covariates, while protecting one or more contrasts of interest.  
    * Protected variables should correspond directly to the hypothesis being tested.  

The example data files in this vignette contain a `sample_info` attribute where libraries are ordered in the same order as what is contained in the count matrix. The objects are set up in this manner to easily apply the same adjustment strategy to all data. This example study has four experimental variables of rat lines, sex, acute exercise groups, and a training group. 
```{r}
# this is a way to apply the same adjustment strategy across all modalities
experimental_vars = c("line", "sex", "grp", "train.sed") 
adj_counts = c(list(RNASeq = gene_counts), peak_counts) |> 
  map(function(.count_mat) {
    pheno_df = attr(.count_mat, "samp")
    # step 1: remove technical variation
    adj_tmp = limma::removeBatchEffect(
      .count_mat, 
      batch = if ("prep_date" %in% colnames(pheno_df)) pheno_df[["prep_date"]] else pheno_df[[""]],
      batch2 = if ("flowcell" %in% colnames(pheno_df)) pheno_df[["flowcell"]] else pheno_df[[""]],
      covariates = pheno_df |> select(starts_with("W_")),
      design = model.matrix(reformulate(experimental_vars), data = pheno_df)
    )
    # step 2: regress out additional experimental covariates, while retaining effects attributed to the experimental group of interest
    adj_counts = adjustCovariateMatrix(
      counts = t(adj_tmp),
      covariate_df = pheno_df |> select(all_of(experimental_vars)), 
      vars_to_protect = "grp" 
    )
    # replace library IDs with common sample IDs that can be matched across matrices 
    rownames(adj_counts) = attr(adj_counts, "samp")[rownames(adj_counts), "samp_id"]
    return(adj_counts)
  })
```

# 3. Correlations
Then, carry out and process the correlations using the following functions. The count matrices used as the input for the correlation analysis should have samples in rows and features in columns.
```{r}
count_mat = formatMatrixForCorrelation(adj_counts$RNASeq, adj_counts |> discard_at("RNASeq"))
# count_mat[1:5,1:5] |> kableExtra::kable()

peak_counts_t = map(peak_counts, function(.x) {
  colnames(.x) = attr(.x, "samp")[colnames(.x), "samp_id"]
  return(t(.x))
}); count_mat = formatMatrixForCorrelation(t(gene_counts), peak_counts_t)

full_cor_res = correlateByChromosome(count_mat, p2g_ls$correlation_pairs)
full_cor_res |> head(5) |> kableExtra::kable()

# this will not run because of the limited genes and peaks included in the example data
# but this is a way to process and interpret the results 
# processed_cor = processCorrelations(count_mat, full_cor_res, p2g_ls$correlation_pairs, p2g_ls$p2g_info)
# processed_cor |> head(5) |> kableExtra::kable()
```

```{r}
sessionInfo()
```
