---
title: "workflow"
output: 
  rmarkdown::html_vignette:
    df_print: kable
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(knitr.table.format = "html")
```

```{r setup, message=FALSE}
# install.packages("pak")
# pak::pak("weitzela/PeakGeneNet")

library(tidyverse)
library(PeakGeneNet)
```

# 1. Data Preparation  



```{r, echo=FALSE}
# Required objects:
#   * Gene counts: this is a matrix where the row names should be ensembl IDs  
#   * Peak counts: a list object with one or more matrices. Matrices should be in same format as gene counts, with row names as genomic region where the chromosome names, start, and end locations are separated by a punctuation mark (e.g., chr1:123:456 or chr1:123-456). 
# gene_counts[1:3,1:3] |> kableExtra::kable()
# 
# peak_counts$ATACSeq[c(200:202, 1:3),1:3] |> kableExtra::kable()
```

Use these objects to create peak-gene pairs for inclusion in the correlation analysis. The `p2g_info` provides information for individual peaks per gene they will be correlated with. The `correlation_pairs` object is used for reference for all of the correlations that will be run.
```{r}
p2g_ls = createPeak2GeneObjects(
  rownames(gene_counts), peak_counts |> map(rownames), 
  biomaRt::useEnsembl(biomart = "genes", 
                      dataset = "rnorvegicus_gene_ensembl", version = 109), 
  "rn7"
)
p2g_ls$p2g_info[1:5,] |> kableExtra::kable()
p2g_ls$correlation_pairs[1:5,] |> kableExtra::kable()
```

See how many relationships will be tested within each category.  
```{r}
p2g_ls$correlation_pairs |> 
  select(-ensembl_gene_id) |> 
  distinct() |> 
  group_by(link_label, modality_pair) |> 
  tally(name = "No. of Correlations") |> 
  janitor::adorn_totals(where = c("row")) |> 
  mutate(across(where(is.numeric), scales::comma)) |> 
  kableExtra::kable()
```

Then, carry out and process the correlations using the following functions. The count matrices used as the input for the correlation analysis should have samples in rows and features in columns.
```{r}
peak_counts_t = map(peak_counts, function(.x) {
  colnames(.x) = attr(.x, "samp")[colnames(.x), "samp_id"]
  return(t(.x))
})
count_mat = formatMatrixForCorrelation(t(gene_counts), peak_counts_t)
count_mat[1:5,1:5] |> kableExtra::kable()

full_cor_res = correlateByChromosome(count_mat, p2g_ls$correlation_pairs)
full_cor_res |> head(5) |> kableExtra::kable()

processed_cor = processCorrelations(count_mat, full_cor_res, p2g_ls$correlation_pairs, p2g_ls$p2g_info)
processed_cor |> head(5) |> kableExtra::kable()
```

```{r}
sessionInfo()
```

